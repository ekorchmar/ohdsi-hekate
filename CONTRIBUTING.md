## Contributing to Hekate
All contributions are welcome! Here are some guidelines to follow when contributing to Hekate.

## Branch policy
Currently, Hekate is being built by a single developer, who commits and pushed to `main` with reckless abandon. Please
contact me via `korchmar@ohdsi.org` if you would like to join the development, and we will agree on a better policy.

## Testing

### Unit tests
We use `pytest` for unit testing. To run the tests, execute the following command in the root of the repository:
```bash
PYTHONPATH=. pytest src/hekate/
```

Note that `.justfile` contains a shortcut for running the tests -- `just test`.

The exemplary input data used for fixtures for testing come from GRR Vocabulary. Right now, I am working to clarify the
IP rights to the mapping data, so the fixtures are not included in the repository.

### Testing environment
No reproducible environment is provided at the moment.


## Tooling

### Virtual environment
We use CPython's built-in `venv` module to manage virtual environments. To create a new virtual environment, run the
following command in the root of the repository:
```bash
python -m venv venv
```

You can activate the virtual environment by running:
```bash
source venv/bin/activate
```
Or, on Windows:
```cmd
venv\Scripts\activate
```

All development dependencies can be installed with `uv` or `pip` by installing Hekate with `[dev]` extras:
```bash
pip install -e .[dev]
```

> [!WARNING]
> We are well aware of shortcomings of `venv` and `requirements.txt` for managing dependencies. However, switching to
> a different tool is not a priority at the moment. Please be cautious when managing dependencies.

### Code style
We use `ruff` for Python code formatting. SQL scripts in `reference/` are formatted with `sqlfluff`.

It is highly recommended to install `pre-commit` and run `pre-commit install` in the root of the repository to ensure
that your code is properly formatted before committing.

### Type annotations
All Python code should be annotated with type hints. We use `pyright` to and ensure that all type hints are correct.

#### Additional type annotation rules
- `typing.Any` is absolutely disallowed. Use explicit type unions and generic function typing. We work with huge data
  tables which are often legacy, manually curated or generated by old versions of software tools with known bugs.
  Keeping all inputs and outputs strictly typed is crucial for validation and debugging.
- `assert` statements are allowed only to indicate a predicate to be true for the type checker. They should not be used
  for runtime checks and control flow. *Python interpreter with `-O` flag will ignore all `assert` statements.*
- Some of the rules are explicitly disabled in `pyproject.toml`. Any additions to that list will be followed up with a
  justification.
- Currently, there are exactly 0 errrors and 0 warnings produced by the static type checkers. Keeping it this way is
  easier than fixing elusive errors on edge cases in long term. If you need to indicate a certain predicate to be true
  for the type checker, use an `assert` statement with a type hint. If you are using `# pyright: ignore[...]`,
  make sue to add a comment explaining why the type checker is wrong.

### Just
We use [`just`](https://github.com/casey/just) as a task runner. You are not required to use it, but it is recommended
for testing convenience. Set environment variables `$ATHENA_DOWNLOAD_DIR` and `$BUILD_RXE_DOWNLOAD_DIR` to source data
paths to avoid having to provide `-a` and `-b` every time you run the program.

### Profiling
High performance is an intended feature of Hekate. We use `scalene` and `snakeviz` for profiling. Make sure to profile
your changes to avoid introducing performance bottlenecks.

#### cProfile
`just profile` will run cProfile and save the results to the `program.prof` file. You can then run
`snakeviz program.prof` to visualize the results.

#### Scalene
Scalene can be used by running `just scalene`. Main feature of Scalene is it's ability to profile not just the Python
code, but also the binary dependencies. However, you will have to install `polars` and `rustworkx` from source, as the
PyPI versions are not compiled with debug symbols.
